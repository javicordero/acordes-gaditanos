---
/**
 * Componente Astro "ChordFormatter"
 *
 * - Pega HTML con <pre> o indica una URL de Blogger.
 * - Ancho fijo: 54 columnas.
 * - Los acordes pertenecen a la línea de texto inmediatamente inferior.
 * - Al cortar texto, los acordes se recolocan conservando columna lógica.
 * - Al usar URL, la salida es SOLO los <pre> procesados.
 */
---

<style>
  :global(body) {
    font-family:
      system-ui,
      -apple-system,
      BlinkMacSystemFont,
      'Segoe UI',
      sans-serif;
  }

  .cf-wrapper {
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    background: #f5f5f5;
    border-radius: 12px;
    border: 1px solid #ddd;
  }

  .cf-title {
    font-size: 1.1rem;
    font-weight: 600;
    margin: 0;
  }

  .cf-note {
    font-size: 0.85rem;
    color: #555;
  }

  .cf-row {
    display: flex;
    flex-direction: row;
    gap: 1rem;
    flex-wrap: wrap;
  }

  .cf-col {
    /* flex: 1 1 300px; */
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
    min-width: 0;
  }

  .cf-label {
    font-size: 0.85rem;
    font-weight: 500;
  }

  .cf-textarea {
    width: 100%;
    min-height: 220px;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    padding: 0.5rem;
    box-sizing: border-box;
    border-radius: 6px;
    border: 1px solid #ccc;
    resize: vertical;
    background: #fff;
    white-space: pre;
  }

  .cf-input-url {
    width: 100%;
    padding: 0.4rem 0.5rem;
    border-radius: 6px;
    border: 1px solid #ccc;
    font-size: 0.9rem;
    box-sizing: border-box;
  }

  .cf-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    align-items: center;
  }

  .cf-btn {
    padding: 0.4rem 0.8rem;
    border-radius: 6px;
    border: 1px solid #333;
    background: #222;
    color: #fff;
    cursor: pointer;
    font-size: 0.85rem;
  }

  .cf-btn:hover {
    background: #444;
  }

  .cf-btn-secondary {
    background: #fff;
    color: #222;
  }

  .cf-btn-secondary:hover {
    background: #eee;
  }

  .cf-small {
    font-size: 0.8rem;
    color: #666;
  }

  .cf-error {
    font-size: 0.85rem;
    color: #b00020;
  }
</style>

<div class='cf-wrapper'>
  <h2 class='cf-title'>Formateador de acordes (54 columnas)</h2>

  <div class='cf-col' style='gap: 0.3rem;'>
    <label class='cf-label' for='cf-url'>Cargar desde URL (Blogger)</label>
    <input
      id='cf-url'
      class='cf-input-url'
      type='text'
      placeholder='https://acordesgaditanos.blogspot.com/...'
    />
  </div>

  <div class='cf-controls'>
    <button type='button' class='cf-btn' id='cf-btn-fetch'>Cargar URL</button>
    <button type='button' class='cf-btn' id='cf-btn-process'> Procesar entrada </button>
    <button type='button' class='cf-btn cf-btn-secondary' id='cf-btn-copy'> Copiar salida </button>
    <button type='button' class='cf-btn cf-btn-secondary' id='cf-btn-download'>
      Descargar .md
    </button>
    <button type='button' class='cf-btn' id='cf-btn-batch'> Procesar todas las URLs </button>

    <span class='cf-small'>Ancho fijo: 54 columnas (sin partir palabras si hay espacio cerca).</span
    >
  </div>

  <div id='cf-progress' style='display: none;'>
    <progress id='cf-progress-bar' max='100' value='0' style='width: 100%;'></progress>
    <p id='cf-progress-text' style='font-size: 0.85rem; margin: 0.5rem 0;'></p>
  </div>

  <div class='cf-row'>
    <div class='cf-col'>
      <label class='cf-label' for='cf-input'> Entrada (HTML completo o solo &lt;pre&gt;) </label>
      <textarea id='cf-input' class='cf-textarea' spellcheck='false'></textarea>
    </div>
    <div class='cf-col'>
      <label class='cf-label' for='cf-output'> Salida (solo &lt;pre&gt; procesado) </label>
      <textarea id='cf-output' class='cf-textarea' spellcheck='false'></textarea>
    </div>
  </div>

  <p id='cf-error' class='cf-error'></p>
</div>

<script is:inline>
  const MAX_COLS = 50;
  let lastMeta = null;

  function setError(msg) {
    const el = document.getElementById('cf-error');
    if (el) el.textContent = msg || '';
  }

  function isChordToken(token) {
    const t = token.trim();
    if (!t) return false;
    const re = /^(do|re|mi|fa|sol|la|si|c|d|e|f|g|a|b)(#|b)?[a-z0-9#/]*$/i;
    return re.test(t);
  }

  function isChordLine(line) {
    const trimmed = line.trim();
    if (!trimmed) return false;
    const tokens = trimmed.split(/\s+/);
    if (!tokens.every(isChordToken)) return false;
    if (tokens.length === 0) return false;
    if (tokens.length > 20) return false;
    return true;
  }

  // envuelve cada acorde en <a>...</a> sin tocar espacios
  function wrapChordLineWithAnchors(line) {
    let res = '';
    let i = 0;
    while (i < line.length) {
      const ch = line[i];
      if (ch === ' ') {
        res += ch;
        i++;
        continue;
      }
      let j = i;
      while (j < line.length && line[j] !== ' ') j++;
      const token = line.slice(i, j);
      if (isChordToken(token)) {
        res += `<a>${token}</a>`;
      } else {
        res += token;
      }
      i = j;
    }
    return res;
  }

  function breakTextLine(line) {
    const chunks = [];
    const len = line.length;
    let start = 0;

    while (start < len) {
      const remaining = len - start;
      if (remaining <= MAX_COLS) {
        chunks.push(line.slice(start));
        break;
      }

      const hardLimit = start + MAX_COLS;
      const softLimit = start + MAX_COLS + 2;
      let cutIndex = -1;
      const maxSearch = Math.min(softLimit, len);

      for (let i = maxSearch; i > start; i--) {
        const prev = i - 1;
        if (prev >= start && line[prev] === ' ') {
          cutIndex = i; // cortamos después del espacio
          break;
        }
      }

      if (cutIndex === -1) {
        cutIndex = hardLimit;
      }

      chunks.push(line.slice(start, cutIndex));
      start = cutIndex;
    }

    return chunks;
  }

  function wrapChordLyricsPair(chordLine, lyricLine) {
    const lyricChunks = breakTextLine(lyricLine);
    const result = [];

    if (chordLine == null) {
      for (const chunk of lyricChunks) {
        result.push({ chord: null, lyric: chunk });
      }
      return result;
    }

    const paddedChord = chordLine.padEnd(lyricLine.length, ' ');
    let start = 0;

    for (const chunk of lyricChunks) {
      const cut = start + chunk.length;
      let chordChunk = paddedChord.slice(start, cut);
      chordChunk = chordChunk.replace(/\s+$/g, '');
      result.push({ chord: chordChunk, lyric: chunk });
      start = cut;
    }

    return result;
  }

  // Devuelve string del bloque <pre> procesado (con <a> en acordes)
  function processPreBlock(preContent) {
    const lines = preContent.split('\n');
    const out = [];
    let i = 0;

    while (i < lines.length) {
      const line = lines[i];

      if (line.trim().length === 0) {
        out.push({ text: line, isChord: false });
        i++;
        continue;
      }

      const thisIsChord = isChordLine(line);

      // pareja acordes (arriba) + texto (debajo)
      if (thisIsChord && i + 1 < lines.length) {
        const nextLine = lines[i + 1];
        const nextIsChord = isChordLine(nextLine);

        if (!nextIsChord && nextLine.trim().length > 0) {
          const pairs = wrapChordLyricsPair(line, nextLine);
          for (const p of pairs) {
            if (p.chord != null && p.chord !== '') {
              out.push({ text: p.chord, isChord: true });
            }
            out.push({ text: p.lyric, isChord: false });
          }
          i += 2;
          continue;
        }
      }

      if (!thisIsChord) {
        const chunks = breakTextLine(line);
        for (const c of chunks) {
          out.push({ text: c, isChord: false });
        }
      } else {
        out.push({ text: line, isChord: true });
      }

      i++;
    }

    // ahora aplicamos los <a> solo a las líneas de acordes
    return out
      .map((item) => (item.isChord ? wrapChordLineWithAnchors(item.text) : item.text))
      .join('\n');
  }

  function extractPreBlocksFromHtml(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const pres = Array.from(doc.querySelectorAll('pre'));
    return pres.map((pre) => pre.textContent || '');
  }

  // ---- META / FRONTMATTER ----

  function extractMetaFromHtml(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');

    const meta = {
      pieza: '',
      agrupacion: '',
      year: '',
      musica: '',
      letra: '',
      img: '',
      cejilla: '',
      date: '',
      video: '',
    };

    // ---------- TÍTULO → pieza + agrupacion ----------
    // Ej: "Acordes Final de Popurrí Una chirigota con shoniket3"
    const titleEl =
      doc.querySelector('h3.post-title, h3.post-title.entry-title') || doc.querySelector('h3');

    if (titleEl) {
      const rawTitle = titleEl.textContent.trim();

      // quitamos "Acordes " del principio
      let t = rawTitle.replace(/^\s*Acordes\s+/i, '').trim();
      // t: "Final de Popurrí Una chirigota con shoniket3"

      // versión normalizada (sin tildes, minúsculas) para comparar
      const tNorm = t
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '') // quita acentos
        .toLowerCase(); // "final de popurri una chirigota..."

      // Caso especial: cuarteta "..."
      if (tNorm.startsWith('cuarteta')) {
        // Intentamos pillar hasta la segunda comilla si existe
        let pieceEnd = t.length;
        const firstQuote = t.indexOf('"');
        if (firstQuote !== -1) {
          const secondQuote = t.indexOf('"', firstQuote + 1);
          if (secondQuote !== -1) {
            pieceEnd = secondQuote + 1;
          } else {
            pieceEnd = 'cuarteta'.length;
          }
        } else {
          pieceEnd = 'cuarteta'.length;
        }
        meta.pieza = t.slice(0, pieceEnd).trim();
        meta.agrupacion = t.slice(pieceEnd).trim();
      } else {
        // Patrones SIN tildes
        const patterns = [
          'presentacion',
          'pasodoble',
          'popurrí',
          'popurri',
          'final de popurri',
          'final del popurri',
          'tango',
        ];

        for (const p of patterns) {
          if (tNorm.startsWith(p)) {
            // Cortamos usando la longitud del patrón NORMALIZADO sobre el título original
            meta.pieza = t.slice(0, p.length).trim(); // ej: "Final de Popurrí"
            meta.agrupacion = t.slice(p.length).trim(); // ej: "Una chirigota con shoniket3"
            break;
          }
        }

        // Si no se ha identificado pieza, todo el título es agrupación
        if (!meta.pieza) {
          meta.agrupacion = t;
        }
      }
    }

    // ---------- ETIQUETAS → year ----------
    const labelLinks = Array.from(doc.querySelectorAll('a')).filter(
      (a) => a.href && a.href.includes('/search/label/')
    );
    const labels = labelLinks.map((a) => a.textContent.trim());
    const yearLabel = labels.find((l) => /^\d{4}$/.test(l));
    if (yearLabel) meta.year = yearLabel;

    // ---------- TEXTO → Autor / Cejilla ----------
    const bodyText = doc.body ? doc.body.textContent || '' : '';

    const autorMatch = bodyText.match(/Autor:\s*([^\n\r]+)/i);
    if (autorMatch) {
      meta.musica = autorMatch[1].trim();
      meta.letra = meta.musica;
    }

    const cejillaMatch = bodyText.match(/Cejilla\s+al\s+(\d+)/i);
    if (cejillaMatch) {
      meta.cejilla = cejillaMatch[1].trim();
    }

    // ---------- IMAGEN → la que tiene clase imgEntrada ----------
    // Prioridad:
    //   1) <img class="imgEntrada">
    //   2) cualquier <img> dentro de un contenedor .imgEntrada
    //   3) primer <img> del documento (fallback)
    let imgEl =
      doc.querySelector('img.imgEntrada') ||
      doc.querySelector('.imgEntrada img') ||
      doc.querySelector('img');

    if (imgEl && imgEl.src) {
      meta.img = imgEl.src;
    }

    // ---------- VÍDEO → primer iframe de YouTube ----------
    const iframe = doc.querySelector("iframe[src*='youtube.com'], iframe[src*='youtu.be']");
    if (iframe && iframe.src) {
      meta.video = iframe.src;
    }

    // ---------- FECHA HOY ----------
    const d = new Date();
    const dd = String(d.getDate()).padStart(2, '0');
    const mm = String(d.getMonth() + 1).padStart(2, '0');
    const yyyy = String(d.getFullYear());
    meta.date = `${dd}/${mm}/${yyyy}`;

    if (!meta.year) meta.year = yyyy;

    return meta;
  }

  function buildFrontmatter(meta) {
    const lines = [];
    lines.push('---');
    if (meta.pieza) lines.push(`pieza: ${meta.pieza}`);
    if (meta.agrupacion) lines.push(`agrupacion: ${meta.agrupacion}`);
    if (meta.year) lines.push(`year: ${meta.year}`);
    if (meta.musica) lines.push(`musica: ${meta.musica}`);
    if (meta.letra) lines.push(`letra: ${meta.letra}`);
    if (meta.img) lines.push(`img: ${meta.img}`);
    if (meta.cejilla) lines.push(`cejilla: ${meta.cejilla}`);
    if (meta.date) lines.push(`date: "${meta.date}"`);
    if (meta.video) lines.push(`video: '${meta.video}'`);
    lines.push('');
    lines.push('---');
    return lines.join('\n');
  }

  function slugify(str) {
    return str
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '') // quita tildes
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-') // cualquier cosa que no sea letra/numero -> "-"
      .replace(/^-+|-+$/g, '') // quita guiones del principio/fin
      .replace(/-+/g, '-'); // colapsa guiones múltiples
  }

  function processDocumentString(input) {
    const meta = extractMetaFromHtml(input);
    lastMeta = meta; // <-- guardamos el último meta
    const blocks = extractPreBlocksFromHtml(input);

    let processedPre = '';
    if (blocks.length > 0) {
      const processedBlocks = blocks.map((inner) => {
        const processedInner = processPreBlock(inner);
        return '<pre>' + processedInner + '</pre>';
      });
      processedPre = processedBlocks.join('\n\n');
    } else {
      const processedAll = processPreBlock(input);
      processedPre = '<pre>' + processedAll + '</pre>';
    }

    const fm = buildFrontmatter(meta);
    return fm + '\n' + processedPre;
  }

  async function fetchFromUrl() {
    setError('');
    const urlInput = document.getElementById('cf-url');
    const inputArea = document.getElementById('cf-input');
    const outputArea = document.getElementById('cf-output');
    if (!urlInput || !inputArea) return;

    const url = urlInput.value.trim();
    if (!url) {
      setError('Introduce primero una URL.');
      return;
    }

    try {
      const proxy = `/api/fetch-url?url=${encodeURIComponent(url)}`;
      const res = await fetch(proxy);
      const text = await res.text();

      if (!res.ok) {
        console.error('Respuesta API fetch-url no OK:', res.status, text);
        throw new Error(`No se pudo descargar la página (status ${res.status}): ${text}`);
      }

      const html = text;

      const blocks = extractPreBlocksFromHtml(html);
      if (blocks.length > 0) {
        inputArea.value = blocks.map((inner) => '<pre>' + inner + '</pre>').join('\n\n');
      } else {
        inputArea.value = html;
        setError('No se encontraron etiquetas <pre> en la página, se ha pegado el HTML completo.');
      }

      if (outputArea) {
        outputArea.value = processDocumentString(html);
        downloadMarkdown();
      }
    } catch (err) {
      console.error(err);
      setError('Error al cargar la URL: ' + (err && err.message ? err.message : String(err)));
    }
  }

  function processCurrentInput() {
    setError('');
    const inputArea = document.getElementById('cf-input');
    const outputArea = document.getElementById('cf-output');
    if (!inputArea || !outputArea) return;
    const text = inputArea.value;
    if (!text.trim()) {
      setError('No hay contenido de entrada para procesar.');
      return;
    }
    const processed = processDocumentString(text);
    outputArea.value = processed;
  }

  function copyOutput() {
    const outputArea = document.getElementById('cf-output');
    if (!outputArea) return;
    outputArea.focus();
    outputArea.select();
    try {
      const ok = document.execCommand('copy');
      if (!ok && navigator.clipboard) {
        navigator.clipboard.writeText(outputArea.value);
      }
    } catch (e) {
      console.error(e);
    }
  }

  function downloadMarkdown() {
    const outputArea = document.getElementById('cf-output');
    if (!outputArea) return;

    const content = outputArea.value;
    if (!content.trim()) {
      setError('No hay contenido para descargar.');
      return;
    }

    // nombre por defecto
    let baseName = 'acordes';

    if (lastMeta && (lastMeta.pieza || lastMeta.agrupacion)) {
      const parts = [];
      if (lastMeta.pieza) parts.push(lastMeta.pieza);
      if (lastMeta.agrupacion) parts.push(lastMeta.agrupacion);
      baseName = slugify(parts.join(' '));
    }

    const blob = new Blob([content], {
      type: 'text/markdown;charset=utf-8',
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = baseName + '.md';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  async function processBatchUrls() {
    setError('');
    const progressContainer = document.getElementById('cf-progress');
    const progressBar = document.getElementById('cf-progress-bar');
    const progressText = document.getElementById('cf-progress-text');

    try {
      // Cargar el JSON con las URLs
      const res = await fetch('/redirects-from.json');
      if (!res.ok) throw new Error('No se pudo cargar redirects-from.json');

      const urls = await res.json();

      if (!Array.isArray(urls) || urls.length === 0) {
        throw new Error('El archivo redirects-from.json está vacío o no es un array');
      }

      // Mostrar barra de progreso
      if (progressContainer) progressContainer.style.display = 'block';
      if (progressBar) progressBar.max = urls.length;

      let successCount = 0;
      let errorCount = 0;

      for (let i = 0; i < urls.length; i++) {
        const path = urls[i];
        const fullUrl = `https://acordesgaditanos.blogspot.com${path}`;

        if (progressText) {
          progressText.textContent = `Procesando ${i + 1}/${urls.length}: ${path}`;
        }

        try {
          // Fetch de la URL
          const proxy = `/api/fetch-url?url=${encodeURIComponent(fullUrl)}`;
          const response = await fetch(proxy);
          const html = await response.text();

          if (!response.ok) {
            console.error(`Error ${response.status} en ${fullUrl}`);
            errorCount++;
            continue;
          }

          // Procesar y descargar
          const meta = extractMetaFromHtml(html);
          const blocks = extractPreBlocksFromHtml(html);

          let processedPre = '';
          if (blocks.length > 0) {
            const processedBlocks = blocks.map((inner) => {
              const processedInner = processPreBlock(inner);
              return '<pre>' + processedInner + '</pre>';
            });
            processedPre = processedBlocks.join('\n\n');
          } else {
            const processedAll = processPreBlock(html);
            processedPre = '<pre>' + processedAll + '</pre>';
          }

          const fm = buildFrontmatter(meta);
          const content = fm + '\n' + processedPre;

          // Generar nombre de archivo
          let baseName = 'acordes';
          if (meta && (meta.pieza || meta.agrupacion)) {
            const parts = [];
            if (meta.pieza) parts.push(meta.pieza);
            if (meta.agrupacion) parts.push(meta.agrupacion);
            baseName = slugify(parts.join(' '));
          }

          // Descargar archivo
          const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = baseName + '.md';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          successCount++;

          // Pequeña pausa para no saturar
          await new Promise((resolve) => setTimeout(resolve, 300));
        } catch (err) {
          console.error(`Error procesando ${fullUrl}:`, err);
          errorCount++;
        }

        // Actualizar barra
        if (progressBar) progressBar.value = i + 1;
      }

      // Resultado final
      if (progressText) {
        progressText.textContent = `✅ Completado: ${successCount} exitosos, ${errorCount} errores`;
      }
    } catch (err) {
      console.error(err);
      setError('Error al procesar batch: ' + (err && err.message ? err.message : String(err)));
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    const btnFetch = document.getElementById('cf-btn-fetch');
    const btnProcess = document.getElementById('cf-btn-process');
    const btnCopy = document.getElementById('cf-btn-copy');
    const btnDownload = document.getElementById('cf-btn-download');
    const btnBatch = document.getElementById('cf-btn-batch');

    if (btnFetch) btnFetch.addEventListener('click', fetchFromUrl);
    if (btnProcess) btnProcess.addEventListener('click', processCurrentInput);
    if (btnCopy) btnCopy.addEventListener('click', copyOutput);
    if (btnDownload) btnDownload.addEventListener('click', downloadMarkdown);
    if (btnBatch) btnBatch.addEventListener('click', processBatchUrls);
  });
</script>
